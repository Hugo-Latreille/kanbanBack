# O'Kanban - E03 - REST API


## Menu du jour 


#### Cockpit

- Correction `MLD` et `MPD`
  - `Timestamps`
  - `Transaction`

- Démarrer la `REST API`
  - Specifications
  - Testing
  - Documentation

#### Atelier

- `REST API` 
  - Routes **Listes**


## REST 

=> Objectif: traduire nos user-stories en API REST

`REST`: REpresentational State Transfer 
- transfer
- state: les données du serveur sont dans un état particulier
- representational : un format pour ces données

RESTful => ajectif pour dire qu'une API respecte bien les standards de REST


Une API REST c'est un ensemble de normes:

- Un ensemble de `ressources` (nos entités !!): ex: cartes, listes, labels
- Client/Serveur
- Stateless: deux appels sont independants
- Cacheable (détail): on peut décider de renvoyer une ressource avec l'option : "coucou client tu peux mettre ça dans ton cache comme ça tu n'a pas besoin de me la redemander avant le B/05/1

- Une API REST utilise le standard HTTP(S)


Une API REST, c'est un ensemble de routes :

- `GET https://mon-api.com/cartes` => obtenir toutes les cartes de l'application 
- `POST https://mon-api.com/cartes` => ajouter une carte
- `PUT https://mon-api.com/cartes/56` => modifier la carte 56

- `GET https://mon-api.com/lists/5/cards` => obtenir toutes les cartes de la liste n°5


## PUT & PATCH

- Patch : 
  - modification partielle d'une ressource
  - [PATCH MDN](https://developer.mozilla.org/fr/docs/Web/HTTP/Methods/PATCH)

- Put :
  - modification (voire création) complète d'une ressource
  - idempotent (plusieurs appels avec le même body => le server fini toujours dans le même état)
  - [PUT MDN](https://developer.mozilla.org/fr/docs/Web/HTTP/Methods/PUT)



### Transactions

- [Voir documentation Postgres](https://www.postgresql.org/docs/current/tutorial-transactions.html)
- Ca existe dans quasi tous les SGBD


### MLD

- On pourrait s'occuper de faire l'équivalent du script `create_tables.sql` en utilisant uniquement `SEQUELIZE`. 


- `GENERATED BY DEFAULT AS IDENTITY` pour avoir un ID qui s'incrémente par défaut.
- `PRIMARY KEY` : pour spécifier que la clé est notre clé primaire
- `TIMESTAMPTZ` : 2022-04-27 16:18:13.147205+02
- (`TIMESTAMP` : 2022-04-27 16:18:13.147205)

- pour le timestamp, NOW() peut aussi être remplacé par `CURRENT_TIMESTAMPTZ` => à privilégier


- `"id" INTEGER GENERATED BY DEFAULT AS IDENTITY` : laisse la possibilité à l'utilisateur de rentrer manuellement les ID. Si on fait du seeding manuelle, je (Enzo) préviligierais cette méthode.
- `"id" INTEGER GENERATED ALWAYS AS IDENTITY` : NE laisse PAS la possibilité à l'utilisateur de rentrer manuellement les ID

- `SERIAL`: [deprecated](https://wiki.postgresql.org/wiki/Don%27t_Do_This#Don.27t_use_serial)


- `text`, `varchar` ou `char` ? 
[Il n'y a aucune différence de performance parmi ces trois types](https://docs.postgresql.fr/9.6/datatype-character.html)
  - peut être utile si on veut limiter le nombre max de caractères pour un champ. 


-  Postgres avec le fait d'ajouter `IDENTITY BY DEFAULT` au lieu de `ALWAYS` ne met pas à jour le curseur de l'incrément de la séquence de façon implicite !
  - => Il faut donc mettre à jour la valeur courante de chacune des séquences en séléctionnant l'id maximum de chaque table


## Le problème de la 'position' des CARTES dans une LISTE

Si je change la position d'une carte, (ex: carte 1 devient 7) 

SOLUTION 1 : je dois bouger position: 7 vers 8 et toute la suite de 1)... C'est chiant. => N opérations (selon la taille et la position où on insère dans la liste)

SOLUTION 2 : link list (3 opérations maximum) - chaque carte connais la carte précédente de la liste et la carte suivante 


SOLUTION 3 : Utiliser des nombres à virgule (ou une chaine de caractère) car il existe toujours un nombre compris entre deux nombres

SOLUTION 4 : un array qqpart qui stocke toutes les positions et on le FORCE UPDATE d'un coup. 



-----
Illustration solution 3

CARTE A    CARTE B    CARTE C      CARTE D
1          2          3            4


=> CARTE A = 3.5



-------------
Illustration solution 2

CARTE A            CARTE B                CARTE C                CARTE D
previous: /        previous: carteA_id    previous: carteB_id    previous carteC_id
next cardB_id      next: carte3_id        next cardC_id          next: /

CARTE A            CARTE B                CARTE C                CARTE D
previous: cardC_d  previous: carteA_id    previous: carteB_id    previous carteA_id
next cardD_id      next: carte3_id        next cardA_id          next: /

ie: 

CARTE B                CARTE C                CARTE A              CARTE D
previous: /            previous: carteB_id    previous: cardC_d    previous carteA_id
next: carte3_id        next cardA_id          next cardD_id        next: /
